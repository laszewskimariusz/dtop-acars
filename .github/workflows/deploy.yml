name: Deploy Django App

on:
  push:
    tags:
      - '*'  # Trigger only on version tags

jobs:
  docker:
    runs-on: ubuntu-latest
    environment: HARBOR
    # ustawiamy KUBECONFIG raz na cały job
    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig.yaml

    steps:
      - name: Checkout source repo
        uses: actions/checkout@v4

      # … pozostałe kroki do build/push obrazu …

      - name: Checkout argo-manifest repo
        uses: actions/checkout@v4
        with:
          repository: laszewskimariusz/argo-manifest
          token: ${{ secrets.GH_PAT }}
          path: argo-manifest

      # … aktualizacja manifestu i commit/push …

      # <-- kolejność ważna: najpierw zapisujemy kubeconfig
      - name: Write kubeconfig to file
        run: |
          cat <<EOF > "$KUBECONFIG"
          ${{ secrets.KUBECONFIG }}
          EOF

      - name: Create dtopsky-secrets in K8s
        run: |
          # dzięki KUBECONFIG wskazanemu wyżej, kubectl będzie używać poprawnego pliku
          kubectl delete secret dtopsky-secrets -n dtopsky --ignore-not-found
          kubectl create secret generic dtopsky-secrets \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=ALLOWED_HOSTS="${{ secrets.ALLOWED_HOSTS }}" \
            --from-literal=DEBUG="False" \
            -n dtopsky

      - name: Verify deployment
        run: |
          kubectl get pods -n dtopsky


    env:
      SECRET_KEY: ${{ secrets.SECRET_KEY }}
      ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
      DEBUG: "False"